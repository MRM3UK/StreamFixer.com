<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamFixer - M3U Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>

    <script src="//cdn.jsdelivr.net/npm/@clappr/player@0.4.0/dist/clappr.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/mux.js@5.6.7/dist/mux.min.js"></script>
    <script src='//cdn.jsdelivr.net/npm/level-selector@latest/dist/level-selector.min.js'></script>
    <script src='//cdn.jsdelivr.net/npm/clappr-chromecast-plugin@latest/dist/clappr-chromecast-plugin.min.js'></script>
    <script src='//cdn.jsdelivr.net/npm/clappr-pip@latest/dist/clappr-pip.min.js'></script>
    <script src='//cdn.jsdelivr.net/npm/clappr-playback-rate-plugin@latest/dist/clappr-playback-rate-plugin.min.js'></script>
    <script src="//cdn.jsdelivr.net/npm/shaka-player@2.5.10/dist/shaka-player.compiled.min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/clappr/dash-shaka-playback@latest/dist/dash-shaka-playback.external.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/cdnbye-shaka@latest"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script> 

    <style>
        /* Custom styles for Dark Theme (Fixed) */
        :root {
            --bg-primary: #1a1a2e; /* Dark background */
            --bg-secondary: #2c2c44; /* Slightly lighter elements */
            --card-bg: #2a2a3e; /* Channel Card Background */
            --text-primary: #f3f4f6; /* Light text for dark theme */
            --action-bg: #4f46e5; /* Indigo/Purple for buttons */
        }
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
        }
        /* Custom styles for editable inputs in dark theme */
        .editable-name, .editable-group {
            color: var(--text-primary) !important; 
            background-color: transparent !important;
        }
        .editable-name:focus, .editable-group:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--card-bg), 0 0 0 4px #8b5cf6; 
            background-color: var(--bg-secondary) !important; 
        }
        /* Style for readonly inputs when default list is loaded */
        .editable-name[readonly], .editable-group[readonly] {
             cursor: default;
             box-shadow: none !important;
             background-color: transparent !important;
        }
        .skeleton {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }
        #telegram-referral {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 50;
        }

        /* Enhanced 3D-like Channel Number Style */
        .channel-number-box {
            font-size: 0.875rem; /* text-sm */
            font-weight: 800; /* font-extrabold */
            color: #d8b4fe; /* text-purple-300 */
            background: linear-gradient(135deg, #4f46e5, #8b5cf6); /* Indigo to Violet gradient */
            padding: 2px 8px;
            border-radius: 4px;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
            display: inline-block;
            line-height: 1;
            transform: translateY(-2px); /* Slight lift for 3D effect */
        }
        
        /* Improved Search Input Field */
        #search-input {
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        #search-input:focus {
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5), 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border-color: #8b5cf6;
        }

        /* CRITICAL: Ensure logo images fit and load fallback gracefully */
        .logo-container img {
            object-fit: contain; /* Ensures the entire logo is visible */
            height: 100%; /* Important for fill */
            width: 100%; /* Important for fill */
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="app" class="p-2 sm:p-4 md:p-8 max-w-7xl mx-auto">
        
        <header class="flex flex-col md:flex-row justify-between items-center py-4 border-b border-gray-700 mb-6">
            <h1 id="website-title" class="text-3xl font-extrabold text-purple-400 mb-4 md:mb-0 cursor-pointer hover:text-purple-300 transition-colors">
                StreamFixer
            </h1>
            
            <div class="flex flex-wrap justify-center md:justify-end items-center space-x-2 sm:space-x-4">
                
                <button id="save-playlist-btn" class="bg-indigo-600 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg hover:bg-indigo-700 transition-colors text-sm font-medium shadow-lg hidden">
                    Save Playlist
                </button>
                <button id="view-saved-btn" class="p-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors shadow-lg">
                    <svg class="w-6 h-6 text-gray-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path></svg>
                </button>

                <div class="flex space-x-2">
                    <label for="file-upload" class="cursor-pointer bg-purple-600 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg hover:bg-purple-700 transition-colors text-sm font-medium shadow-lg">
                        Upload
                    </label>
                    <input type="file" id="file-upload" accept=".m3u" class="hidden">

                    <button id="import-url-btn" class="bg-gray-700 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg hover:bg-gray-600 transition-colors text-sm font-medium shadow-lg">
                        URL
                    </button>
                </div>
                
            </div>
        </header>

        <main id="editor-container" class="hidden">
            <p id="error-message" class="text-center text-lg text-red-500 my-4 hidden"></p>

            <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-between items-center mb-6 p-4 rounded-xl bg-gray-700/50 shadow-lg sticky top-0 z-20">
                
                <input type="text" id="search-input" placeholder="Filter by channel or URL..." class="p-2 border border-gray-600 rounded-lg w-full sm:max-w-xs focus:ring-purple-500 focus:border-purple-500 bg-gray-800 text-white">
                
                <div class="flex flex-wrap justify-center space-x-3 w-full sm:w-auto">
                    <button id="default-list-control-btn" class="bg-indigo-600 text-white px-3 py-1.5 rounded-lg hover:bg-indigo-700 transition-colors text-sm font-medium shadow-md">
                        Default List
                    </button>
                    
                    <button id="add-channel-btn" class="bg-green-600 text-white px-3 py-1.5 rounded-lg hover:bg-green-700 transition-colors text-sm font-medium shadow-md">
                        + Add
                    </button>
                    <button id="add-logos-btn" class="bg-blue-600 text-white px-3 py-1.5 rounded-lg hover:bg-blue-700 transition-colors text-sm font-medium shadow-md">
                        Auto Logos
                    </button>
                    <button id="bulk-name-btn" class="bg-yellow-600 text-white px-3 py-1.5 rounded-lg hover:bg-yellow-700 transition-colors text-sm font-medium shadow-md">
                        Bulk Rename
                    </button>
                </div>

                <button id="export-share-btn" class="bg-purple-600 text-white px-6 py-2 rounded-lg hover:bg-purple-700 transition-colors text-lg font-bold shadow-xl w-full sm:w-auto">
                    Export / Share
                </button>
            </div>
            
            <div id="channel-count-display" class="text-center text-sm font-semibold text-gray-300 mb-4">
                Total Channels: 0
            </div>

            <div id="loading-skeleton" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pb-8 hidden">
                ${Array(12).fill().map((_, i) => `
                    <div class="skeleton bg-gray-700/70 rounded-xl p-4 h-32">
                        <div class="h-6 w-3/4 bg-gray-600 rounded mb-3"></div>
                        <div class="h-4 w-1/2 bg-gray-600 rounded mb-6"></div>
                        <div class="flex space-x-3">
                            <div class="h-8 w-1/4 bg-purple-600 rounded-lg"></div>
                            <div class="h-8 w-1/4 bg-purple-600 rounded-lg"></div>
                        </div>
                    </div>
                `).join('')}
            </div>
            
            <div id="channel-list-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pb-8">
                </div>
            <p id="no-channels-msg" class="text-center text-gray-400 mt-8 hidden">No channels loaded yet.</p>

        </main>
        
        <div id="welcome-screen" class="text-center p-20">
            <h2 class="text-2xl font-semibold mb-4 text-gray-300">Welcome to StreamFixer.</h2>
            <p class="text-gray-400">Importing default playlist... Please wait.</p>
        </div>

        <div id="telegram-referral" class="p-2 bg-gray-800/80 rounded-full shadow-2xl">
            <a href="https://t.me/MR_X_069" target="_blank" title="Join Telegram Channel">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-7 h-7 text-blue-400 hover:text-blue-300 transition-colors" fill="currentColor" viewBox="0 0 24 24"><path d="M11.944 0a12 12 0 1 0 12 12 12 12 0 0 0-12-12zm4.314 8.785a.722.722 0 0 1 .455.906l-2.028 9.53a.754.754 0 0 1-1.077.535l-3.213-2.454c-.21-.161-.5-.078-.718.146l-1.3 1.258a.723.723 0 0 1-1.229-.496l1.246-4.667c.18-.58.423-1.096.535-1.229.078-.078 0-.156 0-.234s0-.156-.156-.234L8.3 10.597a.755.755 0 0 1 .64-.476l5.7-.359a.722.722 0 0 1 .455.02z"/></svg>
            </a>
        </div>


        <div id="generic-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 modal-backdrop">
            <div class="bg-card-bg rounded-xl shadow-2xl w-full max-w-lg transition-all transform scale-100 p-6 max-h-[90vh] overflow-y-auto">
                
                <div class="flex justify-between items-start border-b pb-3 mb-4 border-gray-700 sticky top-0 bg-card-bg z-10">
                    <h3 id="modal-title" class="text-xl font-semibold">Modal Title</h3>
                    <button class="modal-close-btn text-gray-400 hover:text-gray-200">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>

                <div id="modal-content-area">
                    </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let channels = [];
        let currentlyEditingIndex = null;
        let currentPlaylistName = 'Current Working List'; 
        
        const LOCAL_STORAGE_KEY = 'm3ueditor_saved_playlists';
        const LAST_LOADED_KEY = 'm3ueditor_last_loaded';
        const LOGO_BASE_URL = 'https://raw.githubusercontent.com/iptv-org/tv-logos/master/logos/'; 
        
        // **FIXED: YOUR ORIGINAL LOGO URL (Use one that loads correctly in your editor)**
        // আপনার দেওয়া প্রথম URL টি, যা এডিটরে শো করে।
        const ORIGINAL_LOGO_URL = 'https://image.tmdb.org/t/p/original/6KMhKm2ZHG8KUtg4lhsNUdt4iPh.jpg'; 
        
        // **UPDATED: DEFAULT PLAYLIST URL (The uneditable GitHub list)**
        const DEFAULT_PLAYLIST_URL = 'https://raw.githubusercontent.com/MRM3UK/New-try/refs/heads/main/playlist4.m3u';
        
        // **FIXED: USER'S DEFAULT/FALLBACK LOGO (Now points to the original logo)**
        // লোগো লোড না হলে এই লোগোটি দেখাবে
        const DEFAULT_FALLBACK_LOGO = ORIGINAL_LOGO_URL; 
        
        // **CRITICAL FIX: CORS Proxy Constant**
        // লোগো URL লোড করতে এই প্রক্সি ব্যবহার করা হবে।
        const CORS_PROXY_BASE = 'https://corsproxy.io/?'; 

        // New Telegram Link for the Export Message
        const EXPORT_TELEGRAM_LINK = 'https://t.me/TECH_HOUSE_01';

        // Store the name of the playlist that was loaded from the uneditable default URL
        let isDefaultPlaylistLoaded = false;
        const DEFAULT_PLAYLIST_NAME = 'Default GitHub List';

        // Player State: 1 for HLS.js, 2 for Clappr/Shaka
        let currentPlayerMode = 1;

        // Uneditable default channel 
        const TELEGRAM_CHANNEL = {
            name: 't.me/MR_X_069',
            logo: ORIGINAL_LOGO_URL, 
            group: 't.me/MR_X_069',
            url: 'https://pixeldrain.com/api/file/khPX4Kf4' // A placeholder URL
        };


        // --- New CORS Proxy Utility Function (CRITICAL FOR FIX) ---
        /**
         * Returns a proxied URL for the logo, intended to bypass CORS restrictions.
         * @param {string} url - The original logo URL.
         * @returns {string} - The CORS proxied URL.
         */
        const getProxiedLogoUrl = (url) => {
             // Only proxy if the URL seems valid and starts with http/https AND is not one of the internal pixeldrain links
             if (!url || typeof url !== 'string' || !url.trim().startsWith('http') || url.includes('pixeldrain.com')) {
                 return DEFAULT_FALLBACK_LOGO; // Return the user's intended default logo if the URL is invalid or internal
             }
             // The URL to be proxied must be URL-encoded for corsproxy.io
             return `${CORS_PROXY_BASE}${encodeURIComponent(url.trim())}`;
        };
        
        /**
         * Determines the best logo URL to attempt first.
         * @param {string} channelLogoUrl - The logo URL from the M3U file.
         * @returns {string} - The URL to use as the primary `src`.
         */
        const getPrimaryLogoSource = (channelLogoUrl) => {
             if (!channelLogoUrl || !channelLogoUrl.trim().startsWith('http')) {
                 return DEFAULT_FALLBACK_LOGO;
             }
             // **FIX:** We now try the proxied version *first* if the logo is external.
             return getProxiedLogoUrl(channelLogoUrl.trim());
        };


        // --- Header Click Handler (Reloads Page) ---
        document.getElementById('website-title').addEventListener('click', () => {
             window.location.reload();
        });

        // --- UI Utility Functions ---

        const showModal = (title, contentHTML) => {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-content-area').innerHTML = contentHTML;
            document.getElementById('generic-modal').classList.remove('hidden');
        };

        const hideModal = () => {
            document.getElementById('generic-modal').classList.add('hidden');
            // Clean up players on modal close
            const videoElement = document.getElementById('video-player');
            if (videoElement) {
                videoElement.pause();
                videoElement.removeAttribute('src');
                videoElement.load();
            }
            const clapprPlayerDiv = document.getElementById('clappr-player-container');
            if (clapprPlayerDiv) {
                if (window.clapprInstance) {
                    window.clapprInstance.destroy();
                    window.clapprInstance = null;
                }
                clapprPlayerDiv.innerHTML = '';
            }
        };

        document.querySelector('.modal-close-btn').addEventListener('click', hideModal);

        const toggleEditorView = (show) => {
             const welcome = document.getElementById('welcome-screen');
             const editor = document.getElementById('editor-container');
             const saveBtn = document.getElementById('save-playlist-btn');
             const addLogosBtn = document.getElementById('add-logos-btn');
             const bulkNameBtn = document.getElementById('bulk-name-btn');
             const addChannelBtn = document.getElementById('add-channel-btn');
             const defaultControlBtn = document.getElementById('default-list-control-btn');

             if (show) {
                 welcome.classList.add('hidden');
                 editor.classList.remove('hidden');
                 
                 // **CONTROL: Hide ALL editing buttons if default list is loaded**
                 if (isDefaultPlaylistLoaded) { 
                     saveBtn.classList.add('hidden');
                     addLogosBtn.classList.add('hidden');
                     bulkNameBtn.classList.add('hidden');
                     addChannelBtn.classList.add('hidden');
                     defaultControlBtn.textContent = 'Revert/Default Loaded';
                 } else {
                     saveBtn.classList.remove('hidden');
                     addLogosBtn.classList.remove('hidden');
                     bulkNameBtn.classList.remove('hidden');
                     addChannelBtn.classList.remove('hidden');
                     defaultControlBtn.textContent = 'Load GitHub Default';
                 }
             } else {
                 welcome.classList.remove('hidden');
                 editor.classList.add('hidden');
                 saveBtn.classList.add('hidden');
                 addLogosBtn.classList.add('hidden');
                 bulkNameBtn.classList.add('hidden');
                 addChannelBtn.classList.add('hidden');
             }
        }
        
        // --- Persistence (Save/Load/AutoSave) ---

        /** Loads all saved playlists from storage */
        const getSavedPlaylists = () => {
             const data = localStorage.getItem(LOCAL_STORAGE_KEY);
             return data ? JSON.parse(data) : {};
        };
        
        /** Saves the current channels list under the current playlist name, or 'Current Working List' */
        const savePlaylistToStorage = (name = currentPlaylistName, manual = false) => {
            // **CONTROL: Do not auto-save if the current list is the uneditable default list**
            if (isDefaultPlaylistLoaded && !manual) {
                 console.log("Auto-Save skipped: Current list is the uneditable default list.");
                 return;
            }

            if (channels.length === 0) return;

            const playlists = getSavedPlaylists();
            playlists[name] = {
                channels: channels,
                timestamp: Date.now(),
                name: name
            };

            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(playlists));
                currentPlaylistName = name; // Update current name
                localStorage.setItem(LAST_LOADED_KEY, name); // Remember last loaded name
                
                if (!manual) {
                    const saveBtn = document.getElementById('save-playlist-btn');
                    saveBtn.textContent = 'Auto-Saved!';
                    setTimeout(() => saveBtn.textContent = 'Save Playlist', 1500);
                }
            } catch (e) {
                console.error("Failed to save to local storage:", e);
                // alert("Warning: Could not save playlist to local storage. Storage full?");
            }
        };

        /** Loads a specific named playlist from storage */
        const loadNamedPlaylist = (name) => {
            const playlists = getSavedPlaylists();
            const playlist = playlists[name];

            if (playlist && playlist.channels.length > 0) {
                channels = playlist.channels;
                currentPlaylistName = name;
                localStorage.setItem(LAST_LOADED_KEY, name);
                isDefaultPlaylistLoaded = false; // Saved playlists are always editable
                renderChannels();
                toggleEditorView(true);
                return true;
            }
            return false;
        };

        // Manual Save Handler
        document.getElementById('save-playlist-btn').addEventListener('click', () => {
             // Re-check visibility just in case
             if (isDefaultPlaylistLoaded) return; 

            const content = `
                <p class="mb-4 text-gray-300">Name this playlist for future editing. It currently has **${channels.length} channels**.</p>
                <input type="text" id="save-name-input" value="${currentPlaylistName}" class="w-full p-3 border border-gray-700 rounded-lg bg-gray-800 text-white" placeholder="Enter Playlist Name" />
                <button id="submit-save-btn" class="mt-4 bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 w-full font-semibold">Confirm Save</button>
            `;
            showModal('Save Playlist', content);

            document.getElementById('submit-save-btn').addEventListener('click', () => {
                const newName = document.getElementById('save-name-input').value.trim() || `Playlist ${new Date().toLocaleTimeString()}`;
                savePlaylistToStorage(newName, true);
                alert(`Playlist saved as "${newName}".`);
                hideModal();
            });
        });


        // --- View Saved Modal (Updated to list multiple named playlists) ---

        document.getElementById('view-saved-btn').addEventListener('click', () => {
            const playlists = getSavedPlaylists();
            const playlistKeys = Object.keys(playlists).sort((a, b) => playlists[b].timestamp - playlists[a].timestamp);

            if (playlistKeys.length === 0) {
                showModal('Saved Playlists', '<p class="text-center text-gray-400">No playlists found in local storage. Use the "Save Playlist" button to create one.</p>');
                return;
            }

            let content = `<p class="mb-4 text-gray-300">Select a playlist to load or delete:</p><div class="space-y-3">`;

            playlistKeys.forEach(key => {
                const p = playlists[key];
                const date = new Date(p.timestamp).toLocaleString();
                content += `
                    <div class="p-3 bg-gray-700 rounded-lg flex justify-between items-center">
                        <div>
                            <p class="font-semibold text-white">${p.name}</p>
                            <p class="text-xs text-gray-400">${p.channels.length} channels | Saved: ${date}</p>
                        </div>
                        <div class="flex space-x-2">
                            <button data-name="${p.name}" class="load-saved-item-btn bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1 rounded-md font-medium">Load</button>
                            <button data-name="${p.name}" class="delete-saved-item-btn bg-red-600 hover:bg-red-700 text-white text-xs px-3 py-1 rounded-md font-medium">Delete</button>
                        </div>
                    </div>
                `;
            });
            content += '</div>';

            showModal('View Saved Playlists', content);

            // Attach listeners to dynamically created buttons
            document.querySelectorAll('.load-saved-item-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const name = e.currentTarget.dataset.name;
                    if (loadNamedPlaylist(name)) {
                        hideModal();
                    } else {
                        alert('Failed to load playlist.');
                    }
                });
            });

            document.querySelectorAll('.delete-saved-item-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const nameToDelete = e.currentTarget.dataset.name;
                    if(confirm(`Are you sure you want to delete the playlist "${nameToDelete}"?`)) {
                        const allPlaylists = getSavedPlaylists();
                        delete allPlaylists[nameToDelete];
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(allPlaylists));
                        alert(`Playlist "${nameToDelete}" deleted.`);
                        if (currentPlaylistName === nameToDelete) {
                             currentPlaylistName = 'Current Working List';
                             localStorage.removeItem(LAST_LOADED_KEY);
                        }
                        document.getElementById('view-saved-btn').click(); 
                    }
                });
            });
        });
        
        // --- M3U Parsing & Loading ---
        
        const parseM3U = (text) => {
            // **FIX: Use array to store channels to prevent over 300 channel load bottleneck in a single pass**
            // The actual bottleneck is usually DOM rendering/memory, but this ensures fast parsing.
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines[0] !== '#EXTM3U') {
                throw new Error("Invalid M3U file format. Must start with #EXTM3U.");
            }

            const parsedChannels = [];
            let currentChannel = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];

                if (line.startsWith('#EXTINF')) {
                    currentChannel = {};
                    // Extract attributes from the line up to the comma
                    const attributesString = line.substring(line.indexOf(' ')).split(',')[0].trim();
                    // Regex to find all key="value" pairs
                    const attributes = attributesString.match(/([^=]+)="([^"]*)"/g) || [];
                    
                    attributes.forEach(attr => {
                        const [key, value] = attr.split('=').map(s => s.replace(/"/g, ''));
                        if (key.toLowerCase() === 'tvg-name' || key.toLowerCase() === 'channel-name') currentChannel.name = value;
                        if (key.toLowerCase() === 'tvg-logo' || key.toLowerCase() === 'logo') currentChannel.logo = value;
                        if (key.toLowerCase() === 'group-title') currentChannel.group = value;
                    });

                    // Extract the channel title after the last comma
                    const channelTitle = line.substring(line.lastIndexOf(',') + 1).trim();
                    currentChannel.name = (currentChannel.name && currentChannel.name !== '') ? currentChannel.name : channelTitle;
                    currentChannel.logo = currentChannel.logo || ''; 
                    currentChannel.group = currentChannel.group || 'General';

                } else if (line.startsWith('http')) {
                    currentChannel.url = line;
                    parsedChannels.push(currentChannel);
                    currentChannel = {};
                }
            }
            return parsedChannels;
        };

        const loadM3UContent = (content, loadedChannels = null) => {
            const skeleton = document.getElementById('loading-skeleton');
            const errorMessage = document.getElementById('error-message');
            
            toggleEditorView(true); 
            
            skeleton.classList.remove('hidden');
            errorMessage.classList.add('hidden');

            // Reset state for new imports
            if (!loadedChannels) {
                 currentPlaylistName = 'Current Working List';
                 isDefaultPlaylistLoaded = false;
            }

            // **FIX: Use a slight delay for better UI feedback and to allow browser painting (performance improvement)**
            setTimeout(() => { 
                try {
                    let newChannels;
                    if (loadedChannels) {
                        newChannels = loadedChannels; 
                    } else {
                        newChannels = parseM3U(content);
                    }
                    
                    channels = newChannels.filter(c => c.url);
                    skeleton.classList.add('hidden');
                    
                    // The core fix for the 300+ channels is in renderChannels() with filtering.
                    renderChannels(); 
                    
                    savePlaylistToStorage(currentPlaylistName, false); // Auto-save only if not default
                } catch (error) {
                    skeleton.classList.add('hidden');
                    errorMessage.textContent = `Error loading M3U: ${error.message}`;
                    errorMessage.classList.remove('hidden');
                    channels = [];
                    renderChannels();
                    toggleEditorView(false); 
                }
            }, 500);
        };

        // Load playlist from URL
        const loadPlaylistFromUrl = async (url, playlistName) => {
            const welcomeScreen = document.getElementById('welcome-screen');
            const statusMessage = welcomeScreen ? welcomeScreen.querySelector('p') : document.getElementById('url-status-message');
            
            if (statusMessage) {
                 statusMessage.textContent = `Fetching playlist from ${url}...`;
                 statusMessage.classList.remove('text-red-500'); // Reset color
            }
            
            try {
                // **NOTE:** Direct fetch is used here. For true external URL loading without user action,
                // a dedicated server-side proxy is the best/only guaranteed solution. CORS Proxy is for Logos.
                const response = await fetch(url); 
                if (!response.ok) throw new Error(`HTTP error ${response.status}. Check URL and host's CORS policy.`);
                
                const text = await response.text();
                currentPlaylistName = playlistName;
                
                // **CONTROL: Check if this is the default uneditable URL**
                if (url === DEFAULT_PLAYLIST_URL) {
                     isDefaultPlaylistLoaded = true;
                     currentPlaylistName = DEFAULT_PLAYLIST_NAME;
                     localStorage.setItem(LAST_LOADED_KEY, DEFAULT_PLAYLIST_NAME); // Remember it was the default
                } else {
                     isDefaultPlaylistLoaded = false;
                }

                loadM3UContent(text);
                
                // Manually update save button visibility after load
                toggleEditorView(true); // Re-run to update button visibility

            } catch (error) {
                if (statusMessage) {
                     statusMessage.textContent = `Failed to load playlist: ${error.message}. Please try Upload or check your URL.`;
                     statusMessage.classList.add('text-red-500');
                }
                console.error('URL Fetch Error:', error);
                toggleEditorView(false); 
            }
        };


        // --- Import Handlers ---
        
        document.getElementById('file-upload').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => loadM3UContent(e.target.result);
            reader.readAsText(file);
        });

        document.getElementById('import-url-btn').addEventListener('click', () => {
            const content = `
                <input type="url" id="url-input" class="w-full p-3 border border-gray-700 rounded-lg bg-gray-800 text-white" placeholder="Enter full M3U URL" />
                <button id="submit-url-btn" class="mt-4 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 w-full">Fetch Playlist</button>
                <p id="url-status-message" class="mt-2 text-sm text-center text-gray-400"></p>
            `;
            showModal('Import Playlist via URL', content);

            document.getElementById('submit-url-btn').addEventListener('click', async () => {
                const url = document.getElementById('url-input').value;
                const statusMessage = document.getElementById('url-status-message');
                if (!url) return;
                
                statusMessage.textContent = 'Fetching... This may take a moment.';
                
                try {
                    await loadPlaylistFromUrl(url, url); 
                    hideModal();
                } catch (error) {
                    // LoadPlaylistFromUrl already handled status message update
                    console.error('URL Fetch Error:', error);
                }
            });
        });
        
        // --- NEW: Default List Control ---
        document.getElementById('default-list-control-btn').addEventListener('click', () => {
            if (isDefaultPlaylistLoaded) {
                 // The list is currently the default, user wants to revert.
                 if (confirm("You are currently viewing the default list. To load an editable list, please use 'Upload' or 'URL'.")) {
                      // Do nothing, just provide info.
                 }
            } else {
                 // The list is currently editable/custom, user wants to load the default.
                 if (confirm("WARNING: Loading the GitHub Default list will overwrite any unsaved changes in your current working list. Do you want to proceed?")) {
                      const welcome = document.getElementById('welcome-screen');
                      welcome.classList.remove('hidden'); // Show loading screen
                      document.getElementById('editor-container').classList.add('hidden');
                      loadPlaylistFromUrl(DEFAULT_PLAYLIST_URL, DEFAULT_PLAYLIST_NAME);
                      hideModal();
                 }
            }
        });


        // --- Data Editing and Rendering (CRITICAL AREA FOR FIX) ---

        const handleInlineEdit = (e) => {
            // **CONTROL: Block inline editing if default list is loaded**
            if (isDefaultPlaylistLoaded) {
                 e.target.value = e.target.defaultValue; // Revert value
                 alert("This channel cannot be edited because it is part of the default playlist. To edit, you must first save it as your own list or add a new channel.");
                 e.target.blur(); // Remove focus
                 return;
            }

            const input = e.target;
            const index = parseInt(input.dataset.index);
            const field = input.dataset.field;
            const newValue = input.value.trim();

            if (index >= 0 && index < channels.length) {
                channels[index][field] = newValue;
                // Since this is an inline edit, we don't need a full render, but we need to update state and save.
                input.defaultValue = newValue; // Update default value for subsequent checks
                savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                
                // Rerender to apply filters or group changes
                renderChannels();
            }
        };
        
        // **FIX: Improved RENDER function for faster load and better UX**
        const renderChannels = () => {
             const container = document.getElementById('channel-list-container');
             const countDisplay = document.getElementById('channel-count-display');
             const searchText = document.getElementById('search-input').value.toLowerCase();
             
             const filteredChannels = channels.filter(c => 
                 c.name.toLowerCase().includes(searchText) || 
                 c.group.toLowerCase().includes(searchText) ||
                 c.url.toLowerCase().includes(searchText)
             );

             // **FIX for 300+ channel bottleneck:** Only render filtered channels, which is fast.
             // If a list is loaded with >300, the search filter must be used.
             container.innerHTML = ''; 

             countDisplay.textContent = `Total Channels: ${filteredChannels.length} (filtered, out of ${channels.length})`;

             if (filteredChannels.length === 0 && channels.length > 0) {
                 document.getElementById('no-channels-msg').textContent = "No channels match your current filter. Please clear the search or add a channel.";
                 document.getElementById('no-channels-msg').classList.remove('hidden');
                 return;
             } else if (channels.length === 0) {
                 document.getElementById('no-channels-msg').textContent = "No channels loaded yet.";
                 document.getElementById('no-channels-msg').classList.remove('hidden');
                 return;
             }
             document.getElementById('no-channels-msg').classList.add('hidden');
            
             // Determine edit status globally for this render
             const isEditable = !isDefaultPlaylistLoaded;
             const editButtonClass = isEditable ? '' : 'hidden'; 
            
             // 3. Render Cards
             filteredChannels.forEach((channel, index) => {
                 const originalIndex = channels.findIndex(c => c === channel); 
                 
                 // **CRITICAL: IMPROVED LOGO LOGIC WITH CORS PROXY FALLBACK:**
                 const primarySource = getPrimaryLogoSource(channel.logo); 
                 // We use the direct URL as the first fallback
                 const directUrlFallback = (channel.logo && channel.logo.trim().startsWith('http')) ? channel.logo.trim() : DEFAULT_FALLBACK_LOGO;
                 const finalFallbackUrl = 'https://via.placeholder.com/128x128.png?text=NO+LOGO'; 
                 
                 // The onerror sequence: 
                 // 1. If primarySource (proxied or default) fails, try the direct URL (the original URL).
                 // 2. If the direct URL fails, use the final generic NO LOGO placeholder.
                 const logoHtml = `
                     <img src="${primarySource}" alt="${channel.name} logo" class="w-full h-full object-contain p-0.5" 
                          onerror="this.onerror=null; this.src='${directUrlFallback}'; this.onerror=function(){this.onerror=null; this.src='${finalFallbackUrl}';}" />
                 `;
                 
                 const channelNumber = originalIndex + 1;
                 
                 const card = document.createElement('div');
                 card.className = 'bg-card-bg rounded-xl p-4 shadow-xl border border-gray-700/50 flex flex-col space-y-3';
                 card.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <div class="logo-container flex-shrink-0 w-12 h-12 bg-gray-700 rounded-md overflow-hidden relative mr-3">
                            ${logoHtml}
                        </div>
                        <div class="flex-grow min-w-0">
                            <div class="flex items-baseline">
                                <span class="channel-number-box mr-2">#${channelNumber}</span>
                                <input type="text" value="${channel.name}" data-index="${originalIndex}" data-field="name" 
                                       class="editable-name font-bold text-lg w-full p-0.5 rounded-md truncate focus:shadow-none" 
                                       title="${isEditable ? 'Click to edit Name' : 'Cannot edit default list'}" 
                                       ${isEditable ? '' : 'readonly'}/>
                            </div>
                            
                            <div class="text-xs text-purple-400 mt-1">
                                <input type="text" value="${channel.group}" data-index="${originalIndex}" data-field="group" 
                                       class="editable-group font-medium w-full p-0.5 rounded-md focus:shadow-none" 
                                       title="${isEditable ? 'Click to edit Group' : 'Cannot edit default list'}" 
                                       ${isEditable ? '' : 'readonly'}/>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-start space-x-3 pt-3 border-t border-gray-700">
                        <button class="play-btn bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded-lg text-sm font-medium flex items-center space-x-1 transition-colors" data-index="${originalIndex}">
                             <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                             <span>Play</span>
                        </button>
                        <button class="edit-btn bg-gray-700 hover:bg-gray-600 text-white px-3 py-1.5 rounded-lg text-sm font-medium flex items-center space-x-1 transition-colors ${editButtonClass}" data-index="${originalIndex}">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                            <span>Edit</span>
                        </button>
                    </div>
                 `;
                 container.appendChild(card);
             });

            attachActionListeners();
        };

        const attachActionListeners = () => {
            // Remove existing listeners to prevent duplicates (only for safety in a full render flow)
            document.getElementById('search-input').oninput = renderChannels;
            
            document.querySelectorAll('.editable-name, .editable-group').forEach(input => {
                 // **CONTROL: Only attach change listener if not the default list**
                if (!isDefaultPlaylistLoaded) { 
                    input.onchange = handleInlineEdit;
                    // Ensure the readonly attribute is removed if it's editable
                    input.removeAttribute('readonly');
                } else {
                     input.setAttribute('readonly', 'readonly');
                }
            });
            // Attach play/edit listeners
            document.querySelectorAll('.edit-btn:not(.hidden)').forEach(button => {
                button.onclick = (e) => showFullEditModal(e.currentTarget.dataset.index);
            });
            document.querySelectorAll('.play-btn').forEach(button => {
                button.onclick = (e) => showPlaybackModal(e.currentTarget.dataset.index);
            });
            
            // Hide/Show bulk edit buttons based on list status (Re-run for every render)
            document.getElementById('save-playlist-btn').classList.toggle('hidden', isDefaultPlaylistLoaded);
            document.getElementById('add-logos-btn').classList.toggle('hidden', isDefaultPlaylistLoaded);
            document.getElementById('bulk-name-btn').classList.toggle('hidden', isDefaultPlaylistLoaded);
            document.getElementById('add-channel-btn').classList.toggle('hidden', isDefaultPlaylistLoaded);
            
            document.getElementById('default-list-control-btn').textContent = isDefaultPlaylistLoaded ? 'Default List Loaded' : 'Load GitHub Default';
        };


        const showFullEditModal = (index, isNew = false) => {
            // **CONTROL: Block edit if default list is loaded AND channel is not new**
            if (isDefaultPlaylistLoaded && !isNew) {
                 alert("This channel cannot be edited because it is part of the default playlist. To edit, you must first save it as your own list or add a new channel.");
                 hideModal();
                 return;
            }

            currentlyEditingIndex = parseInt(index);
            const channel = channels[currentlyEditingIndex] || { name: '', logo: '', group: '', url: '' };
            
            const content = `
                <div class="space-y-4">
                    <label class="block text-gray-300">Channel Name:
                        <input type="text" id="edit-name" value="${channel.name}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">Logo URL:
                        <input type="url" id="edit-logo" value="${channel.logo}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">Group Title:
                        <input type="text" id="edit-group" value="${channel.group}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">Stream URL (Full M3U8/HTTP link):
                        <textarea id="edit-url" rows="3" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">${channel.url}</textarea>
                    </label>
                </div>
                <div class="flex justify-between mt-6 space-x-3">
                    <button id="delete-channel-btn" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 font-semibold flex-1 ${isNew ? 'hidden' : ''}">Delete</button>
                    <button id="save-channel-btn" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 font-semibold flex-1">Save & Close</button>
                </div>
            `;
            showModal(isNew ? 'Add New Channel' : 'Edit Full Details', content);

            document.getElementById('save-channel-btn').addEventListener('click', () => {
                channels[currentlyEditingIndex] = {
                    name: document.getElementById('edit-name').value.trim(),
                    logo: document.getElementById('edit-logo').value.trim(),
                    group: document.getElementById('edit-group').value.trim(),
                    url: document.getElementById('edit-url').value.trim(),
                };
                
                // If the user adds a new channel OR edits an existing one while viewing the default list, 
                // the list becomes "customized" and editable.
                if (isDefaultPlaylistLoaded) {
                     isDefaultPlaylistLoaded = false;
                     toggleEditorView(true); // show save button
                }

                renderChannels();
                savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                hideModal();
            });

            if (!isNew) {
                 document.getElementById('delete-channel-btn').addEventListener('click', () => {
                    if (confirm("Are you sure you want to delete this channel?")) {
                        channels.splice(currentlyEditingIndex, 1);
                        
                        // Deleting a channel from a default list also makes it custom/editable
                        if (isDefaultPlaylistLoaded) {
                             isDefaultPlaylistLoaded = false;
                             toggleEditorView(true);
                        }

                        renderChannels();
                        savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                        hideModal();
                    }
                 });
            }
        };

        document.getElementById('add-channel-btn').addEventListener('click', () => {
            const newChannelTemplate = { name: 'New Channel', logo: '', group: 'Custom', url: '' };
            channels.push(newChannelTemplate);
            
            // Adding a channel always makes the list editable
            if (isDefaultPlaylistLoaded) {
                isDefaultPlaylistLoaded = false;
                toggleEditorView(true);
            }
            
            showFullEditModal(channels.length - 1, true); 
        });


        // --- ADVANCED Bulk Editor (Hidden if default list is loaded) ---
        
        document.getElementById('bulk-name-btn').addEventListener('click', () => {
             if (isDefaultPlaylistLoaded) return; // Should be hidden, but safety check

            if (channels.length === 0) {
                 alert("Please load a playlist first.");
                 return;
             }
             
            // The modal itself is scrollable via the added style: max-h-[90vh] overflow-y-auto
            const content = `
                <div class="space-y-4">
                    <p class="mb-4 text-sm text-gray-400">Apply a change to a continuous range of channels.</p>
                    
                    <h4 class="text-md font-semibold text-purple-400">1. Channel Range</h4>
                    <label class="block text-gray-300">Start Row # (1 for first channel):
                        <input type="number" id="start-index" value="1" min="1" max="${channels.length}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">End Row # (Optional, leave blank for all remaining):
                        <input type="number" id="end-index" value="${channels.length}" min="1" max="${channels.length}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>

                    <h4 class="text-md font-semibold text-purple-400 pt-4 border-t border-gray-700">2. Renaming (Optional)</h4>
                    <label class="block text-gray-300">Base Name (Optional, for S/E numbering):
                        <input type="text" id="bulk-base-name" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1" placeholder="e.g., The Series Title">
                    </label>
                    <div class="flex space-x-4">
                        <label class="block w-1/2 text-gray-300">Start Season (e.g., 1):
                            <input type="number" id="start-season" value="1" min="1" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                        </label>
                        <label class="block w-1/2 text-gray-300">Start Episode (e.g., 1):
                            <input type="number" id="start-episode" value="1" min="1" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                        </label>
                    </div>

                    <h4 class="text-md font-semibold text-purple-400 pt-4 border-t border-gray-700">3. Other Bulk Edits (Optional)</h4>
                    <label class="block text-gray-300">New Group Title (Optional, leave blank to skip):
                        <input type="text" id="new-group-title" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1" placeholder="e.g., Movies HD">
                    </label>
                    <label class="block text-gray-300">New Logo URL (Optional, leave blank to skip):
                        <input type="url" id="new-logo-url" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1" placeholder="e.g., http://mylogos.com/default.png">
                    </label>
                </div>
                <button id="submit-bulk-name-btn" class="mt-6 bg-yellow-600 text-white px-4 py-2 rounded-lg hover:bg-yellow-700 w-full font-semibold">Apply Bulk Edits</button>
                <p id="bulk-status-message" class="mt-3 text-center text-sm text-gray-400"></p>
            `;
            showModal('Advanced Bulk Editor', content);

            document.getElementById('submit-bulk-name-btn').addEventListener('click', () => {
                const baseName = document.getElementById('bulk-base-name').value.trim();
                let currentSeason = parseInt(document.getElementById('start-season').value);
                let currentEpisode = parseInt(document.getElementById('start-episode').value);
                const startIndex = parseInt(document.getElementById('start-index').value) - 1; // 0-based
                const endIndex = parseInt(document.getElementById('end-index').value); // Exclusive/end index is usually the number itself
                const newGroupTitle = document.getElementById('new-group-title').value.trim();
                const newLogoUrl = document.getElementById('new-logo-url').value.trim();

                const statusMessage = document.getElementById('bulk-status-message');
                let count = 0;

                if (startIndex < 0 || startIndex >= channels.length) {
                    statusMessage.textContent = 'Start Row number is invalid.';
                    statusMessage.classList.add('text-red-500');
                    return;
                }

                const actualEndIndex = Math.min(endIndex, channels.length);

                for (let i = startIndex; i < actualEndIndex; i++) {
                    // 1. Rename logic (S/E sequencing)
                    if (baseName || !isNaN(currentSeason) || !isNaN(currentEpisode)) {
                        const s = String(currentSeason).padStart(2, '0');
                        const e = String(currentEpisode).padStart(2, '0');
                        const prefix = `S${s}E${e}`;
                        
                        channels[i].name = baseName ? `${baseName} - ${prefix}` : `${prefix} ${channels[i].name}`;
                        currentEpisode++;
                    }

                    // 2. Group Title change
                    if (newGroupTitle) {
                        channels[i].group = newGroupTitle;
                    }

                    // 3. Logo URL change
                    if (newLogoUrl) {
                        channels[i].logo = newLogoUrl;
                    }

                    count++;
                }
                
                renderChannels();
                savePlaylistToStorage(currentPlaylistName, false); 
                statusMessage.textContent = `Successfully updated ${count} channels.`;
                statusMessage.classList.remove('text-red-500');
                statusMessage.classList.add('text-green-500');
                setTimeout(hideModal, 2000);
            });
        });

        // --- Logo Matching Logic (Hidden if default list is loaded) ---
        
        const slugifyChannelName = (name) => {
             return name
                .toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^\w\-]+/g, '')
                .replace(/\-\-+/g, '-')
                .replace(/^-+/, '')
                .replace(/-+$/, '');
        };

        document.getElementById('add-logos-btn').addEventListener('click', () => {
             if (isDefaultPlaylistLoaded) return; // Should be hidden, but safety check
             
             if (channels.length === 0) {
                 alert("Please load a playlist first.");
                 return;
             }

             const channelGroups = [...new Set(channels.map(c => c.group))];
             const groupOptions = channelGroups.map(g => `<option value="${g}">${g}</option>`).join('');

             const content = `
                <div class="space-y-4">
                    <p class="mb-4 text-sm text-gray-400">Match channel names to logos using a database structure. Use 'Specific Group' for **multiple logo ranges**.</p>
                    <label class="block text-gray-300">Target Channels:
                        <select id="logo-target" class="mt-1 block w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white">
                            <option value="all">All Channels</option>
                            <option value="missing">Only Channels with Missing Logos</option>
                            <option value="group">Specific Group...</option>
                        </select>
                    </label>

                    <label id="group-select-container" class="block hidden text-gray-300">Select Group:
                        <select id="logo-group-target" class="mt-1 block w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white">
                            ${groupOptions}
                        </select>
                    </label>

                    <label class="block text-gray-300">Base Logo URL:
                        <input type="text" id="logo-base-input" value="${LOGO_BASE_URL}" class="mt-1 block w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white">
                        <p class="text-xs text-gray-500 mt-1">URL format: BASE_URL/[channel-name-slugified].png</p>
                    </label>
                </div>
                
                <button id="submit-logo-btn" class="mt-6 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 w-full font-semibold">Apply Logos</button>
                <p id="logo-status-message" class="mt-3 text-center text-sm text-gray-400"></p>
             `;
             showModal('Auto Add Logos', content);

             document.getElementById('logo-target').addEventListener('change', (e) => {
                 document.getElementById('group-select-container').classList.toggle('hidden', e.target.value !== 'group');
             });

             document.getElementById('submit-logo-btn').addEventListener('click', () => {
                 const target = document.getElementById('logo-target').value;
                 const baseLogoUrl = document.getElementById('logo-base-input').value.trim().replace(/\/+$/, '');
                 const groupTarget = document.getElementById('logo-group-target')?.value;
                 const statusMessage = document.getElementById('logo-status-message');
                 let logosAppliedCount = 0;
                 
                 channels = channels.map(channel => {
                     let shouldApply = false;
                     if (target === 'all') shouldApply = true;
                     else if (target === 'missing' && channel.logo === '') shouldApply = true;
                     else if (target === 'group' && channel.group === groupTarget) shouldApply = true;

                     if (shouldApply) {
                         const slug = slugifyChannelName(channel.name);
                         const newLogoUrl = baseLogoUrl + '/' + slug + '.png';
                         
                         if (channel.logo !== newLogoUrl) {
                             channel.logo = newLogoUrl;
                             logosAppliedCount++;
                         }
                     }
                     return channel;
                 });

                 renderChannels();
                 savePlaylistToStorage(currentPlaylistName, false); 
                 statusMessage.textContent = `Success! Updated logos for ${logosAppliedCount} channels.`;
                 statusMessage.classList.remove('text-red-500');
                 statusMessage.classList.add('text-green-500');
                 setTimeout(hideModal, 2000);
             });
        });

        // --- Export and Share Logic (UPDATED MESSAGE) ---

        const generateM3UPlaylist = (channelList) => {
            let m3uContent = '#EXTM3U\n';
            
            // 1. Add mandatory Telegram channel first
            m3uContent += '#EXTINF:-1';
            m3uContent += ` tvg-logo="${TELEGRAM_CHANNEL.logo}"`;
            m3uContent += ` group-title="${TELEGRAM_CHANNEL.group}"`;
            m3uContent += `,${TELEGRAM_CHANNEL.name}\n`;
            m3uContent += `${TELEGRAM_CHANNEL.url}\n`;

            // 2. Add user's channels
            channelList.forEach(channel => {
                if (!channel.name || !channel.url) return; 
                m3uContent += '#EXTINF:-1';
                if (channel.logo && channel.logo.length > 0) m3uContent += ` tvg-logo="${channel.logo}"`;
                if (channel.group && channel.group.length > 0) m3uContent += ` group-title="${channel.group}"`;
                m3uContent += `,${channel.name}\n`;
                m3uContent += `${channel.url}\n`;
            });
            return m3uContent;
        };

        document.getElementById('export-share-btn').addEventListener('click', () => {
            const m3uCode = generateM3UPlaylist(channels);
            
            const content = `
                <div class="space-y-4">
                    <p class="text-gray-300">Select an option to save or share your updated playlist.</p>
                    <p class="text-yellow-400 text-sm">Join the Telegram channel for updates: <a href="${EXPORT_TELEGRAM_LINK}" target="_blank" class="text-blue-400 hover:underline font-semibold">${EXPORT_TELEGRAM_LINK}</a></p>

                    <textarea id="playlist-code-display" rows="8" readonly class="w-full p-3 border border-gray-700 rounded-lg bg-gray-900 text-green-400 text-sm font-mono">${m3uCode}</textarea>

                    <div class="flex flex-col space-y-3">
                        <button id="copy-code-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 font-semibold transition-colors">Copy Full M3U Playlist Code</button>
                        <button id="download-m3u-btn" data-format="m3u" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 font-semibold transition-colors">Download as .m3u File</button>
                        <button id="download-txt-btn" data-format="txt" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 font-semibold transition-colors">Download as .txt File (Plain Text)</button>
                    </div>
                    <p id="export-status" class="mt-3 text-center text-sm text-gray-400"></p>
                </div>
            `;
            showModal('Export & Share Playlist', content);

            // Copy to Clipboard Logic
            document.getElementById('copy-code-btn').addEventListener('click', () => {
                navigator.clipboard.writeText(m3uCode).then(() => {
                    const status = document.getElementById('export-status');
                    status.textContent = 'Playlist code copied to clipboard!';
                    status.classList.add('text-green-400');
                    setTimeout(() => status.textContent = '', 1500);
                }).catch(err => {
                    document.getElementById('export-status').textContent = 'Failed to copy.';
                    console.error('Copy failed: ', err);
                });
            });

            // Download Logic
            document.getElementById('download-m3u-btn').addEventListener('click', (e) => downloadFile(m3uCode, `M3U_Editor_Pro_${currentPlaylistName.replace(/[^a-zA-Z0-9]/g, '_')}.m3u`, 'audio/x-mpegurl'));
            document.getElementById('download-txt-btn').addEventListener('click', (e) => downloadFile(m3uCode, `M3U_Editor_Pro_${currentPlaylistName.replace(/[^a-zA-Z0-9]/g, '_')}.txt`, 'text/plain'));
        });
        
        const downloadFile = (content, fileName, mimeType) => {
            const blob = new Blob([content], { type: mimeType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            const status = document.getElementById('export-status');
            status.textContent = `Downloading ${fileName}...`;
            status.classList.add('text-green-400');
            setTimeout(() => status.textContent = '', 1500);
        };
        
        // --- Playback Modal Logic (UPDATED with Telegram Icon and Player Fallback) ---

        const showPlaybackModal = (index) => {
            const channel = channels[parseInt(index)];
            
            // Initial guess for player mode
            const url = channel.url.toLowerCase();
            // Start with Player 1 (HLS.js/Native) unless it's a known DASH/MPD
            currentPlayerMode = (url.includes('.mpd') || url.includes('.dash')) ? 2 : 1; 

            // **IMPROVED LOGO LOGIC for Player Modal (with CORS Proxy Fallback):**
            const logoSource = getPrimaryLogoSource(channel.logo); 
            const directUrlFallback = (channel.logo && channel.logo.trim().startsWith('http')) ? channel.logo.trim() : DEFAULT_FALLBACK_LOGO;
            const finalFallbackUrl = 'https://via.placeholder.com/128x128.png?text=NO+LOGO'; 

            const playerHeader = `
                <div class="flex items-center space-x-3 mb-4">
                    <img id="player-modal-logo" src="${logoSource}" alt="Logo" class="w-10 h-10 object-contain bg-gray-700 rounded-md p-0.5" 
                        onerror="this.onerror=null; this.src='${directUrlFallback}'; this.onerror=function(){this.onerror=null; this.src='${finalFallbackUrl}';}">
                    <h4 class="text-xl font-bold">${channel.name}</h4>
                    
                    <a href="${EXPORT_TELEGRAM_LINK}" target="_blank" title="Join Telegram" class="text-blue-400 hover:text-blue-300 transition-colors ml-4">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M11.944 0a12 12 0 1 0 12 12 12 12 0 0 0-12-12zm4.314 8.785a.722.722 0 0 1 .455.906l-2.028 9.53a.754.754 0 0 1-1.077.535l-3.213-2.454c-.21-.161-.5-.078-.718.146l-1.3 1.258a.723.723 0 0 1-1.229-.496l1.246-4.667c.18-.58.423-1.096.535-1.229.078-.078 0-.156 0-.234s0-.156-.156-.234L8.3 10.597a.755.755 0 0 1 .64-.476l5.7-.359a.722.722 0 0 1 .455.02z"/></svg>
                    </a>
                    
                </div>
                
                <div class="mb-4 flex space-x-3 items-center">
                    <span id="current-player-status" class="text-sm font-medium text-purple-400">Player 1 (HLS.js/Native)</span>
                    <button id="change-player-btn" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1.5 rounded-lg text-sm font-medium transition-colors">
                        Change Player
                    </button>
                </div>
            `;
            
            const playerBody = `<div id="player-container" class="w-full bg-black rounded-lg shadow-xl aspect-video relative"></div><p id="player-status" class="mt-4 text-center text-sm text-yellow-400"></p>`;

            showModal('Test Playback', playerHeader + playerBody);
            
            loadPlayer(channel, currentPlayerMode);
            
            document.getElementById('change-player-btn').addEventListener('click', () => {
                currentPlayerMode = (currentPlayerMode === 1) ? 2 : 1; 
                loadPlayer(channel, currentPlayerMode);
            });
        };

        const updatePlayerStatus = (mode) => {
             const statusElement = document.getElementById('current-player-status');
             if (statusElement) {
                 statusElement.textContent = (mode === 1) ? 'Player 1 (HLS.js/Native)' : 'Player 2 (Clappr/Shaka)';
             }
        }

        /**
         * Loads the player for the given channel and mode.
         * @param {object} channel - The channel object.
         * @param {number} mode - 1 for HLS.js/Native, 2 for Clappr/Shaka.
         * @param {boolean} initialAttempt - True if this is the first attempt, used for fallback logic.
         */
        const loadPlayer = (channel, mode, initialAttempt = true) => {
            const container = document.getElementById('player-container');
            const status = document.getElementById('player-status');
            container.innerHTML = ''; 
            
            if (window.clapprInstance) {
                window.clapprInstance.destroy();
                window.clapprInstance = null;
            }
            
            updatePlayerStatus(mode);
            status.textContent = `Initializing Player ${mode}...`;
            
            // **IMPROVED LOGO LOGIC for Player Poster (same as modal logo):**
            const posterUrl = getPrimaryLogoSource(channel.logo); 

            if (mode === 1) {
                const videoHTML = `<video id="video-player" controls autoplay class="w-full h-full bg-black" poster="${posterUrl}"></video>`;
                container.innerHTML = videoHTML;
                const video = document.getElementById('video-player');
                
                const url = channel.url;
                const isHLS = url.toLowerCase().includes('.m3u8');
                const isDASH = url.toLowerCase().includes('.mpd') || url.toLowerCase().includes('.dash');

                if (isHLS && Hls.isSupported()) {
                    // HLS.js for HLS streams
                    const hls = new Hls();
                    hls.loadSource(url);
                    hls.attachMedia(video);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        video.play().catch(() => {});
                        status.textContent = 'Playback successful (HLS.js)';
                    });
                    
                    hls.on(Hls.Events.ERROR, (event, data) => {
                        if (data.fatal && initialAttempt) {
                            status.textContent = `P1 Error: ${data.details}. Switching to Player 2...`;
                            setTimeout(() => loadPlayer(channel, 2, false), 1500); 
                        } else if (data.fatal) {
                            status.textContent = `P1 Error: ${data.details}. Failed to load stream.`;
                        }
                    });

                } else if (!isHLS && !isDASH) {
                    // Native HTML5 playback for simple MP4/other streams
                    video.src = url;
                    
                    video.play().catch(e => {
                        if (initialAttempt) {
                            status.textContent = `P1 Failed (Native Playback). Trying Player 2...`;
                            setTimeout(() => loadPlayer(channel, 2, false), 1500); 
                        } else {
                            status.textContent = `Playback Failed (Player 1). Stream invalid, format unsupported, or CORS blocked.`;
                        }
                    });
                    
                    video.addEventListener('error', (e) => {
                        // If it's a generic stream (not HLS/DASH) and initial attempt failed, try player 2
                        if (initialAttempt) {
                            status.textContent = `P1 Load Error. Trying Player 2...`;
                            setTimeout(() => loadPlayer(channel, 2, false), 1500); 
                        } else {
                            status.textContent = `Playback Failed (Player 1). Stream invalid or CORS blocked.`;
                        }
                    }, { once: true });
                    
                } else {
                     // For non-HLS streams that are DASH/MPD or other complex formats, fall straight to Player 2
                     if (initialAttempt) {
                          status.textContent = `P1 not supported for this format. Switching to Player 2...`;
                          setTimeout(() => loadPlayer(channel, 2, false), 500);
                     } else {
                          status.textContent = `P1 Failed. Stream format not supported by HLS.js or Native Player.`;
                     }
                }
            
            } else if (mode === 2) {
                // Clappr/Shaka Player
                container.innerHTML = `<div id="clappr-player-container" class="w-full h-full"></div>`;
                status.textContent = 'Initializing Player 2 (Clappr/Shaka). Best for DASH/DRM...';
                
                const mimeType = (channel.url.toLowerCase().includes('.mpd') || channel.url.toLowerCase().includes('.dash')) ? 'application/dash+xml' : 'application/x-mpegurl';
                
                window.clapprInstance = new Clappr.Player({
                    source: channel.url,
                    mimeType: mimeType,
                    height: '100%',
                    width: '100%',
                    poster: posterUrl,
                    autoPlay: true,
                    allowUserInteraction: true,
                    preload: 'auto',
                    plugins: [LevelSelector, DashShakaPlayback, ChromecastPlugin, ClapprPip.PipButton, ClapprPip.PipPlugin],
                    events: {
                        onReady: function() {
                            status.textContent = 'Playback successful (Clappr/Shaka)';
                        },
                        onError: function(e) {
                             status.textContent = 'Playback Failed (Player 2). Stream invalid or format unsupported by Shaka/Clappr.';
                             console.error("Clappr/Shaka Error:", e);
                        }
                    },
                    // Shaka configuration for potential DRM/ClearKey (optional, but good to keep)
                    shakaConfiguration: {
                        drm: {
                            clearKeys: {
                                'clearkey1':'clearkey2' 
                            }
                        },
                        preferredAudioLanguage: 'en-US',
                    },
                    parentId: '#clappr-player-container'
                });
            }
        };

        // --- Initialization ---

        const checkInitialState = () => {
            const lastLoadedName = localStorage.getItem(LAST_LOADED_KEY);
            
            // 1. Try to auto-load the last working saved playlist
            if (lastLoadedName && lastLoadedName !== DEFAULT_PLAYLIST_NAME) {
                const playlists = getSavedPlaylists();
                if (playlists[lastLoadedName]) {
                    loadNamedPlaylist(lastLoadedName);
                    return;
                }
            }
            
            // 2. If no saved playlist, load the default URL
            if (DEFAULT_PLAYLIST_URL) {
                 loadPlaylistFromUrl(DEFAULT_PLAYLIST_URL, DEFAULT_PLAYLIST_NAME);
                 return;
            }

            // 3. Fallback to the welcome screen if nothing is set
            toggleEditorView(false);
        }
        
        checkInitialState();
    </script>
</body>
</html>
