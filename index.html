<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3U Editor Pro (Final)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
    <style>
        /* Custom styles for Dark Theme (Fixed) */
        :root {
            --bg-primary: #1a1a2e; /* Dark background */
            --bg-secondary: #2c2c44; /* Slightly lighter elements */
            --card-bg: #2a2a3e; /* Channel Card Background */
            --text-primary: #f3f4f6; /* Light text for dark theme */
            --action-bg: #4f46e5; /* Indigo/Purple for buttons */
        }
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        /* Style for the Modal backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
        }
        /* FIX: Ensure editable fields on the card are visible */
        .editable-name, .editable-group {
            color: var(--text-primary) !important; 
            background-color: transparent !important;
        }
        /* Mobile-friendly edit state */
        .editable-name:focus, .editable-group:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--card-bg), 0 0 0 4px #8b5cf6; 
            background-color: var(--bg-secondary) !important; 
        }
        /* Skeleton Loader Animation */
        .skeleton {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }
        /* Telegram Sticky Corner (Subtle) */
        #telegram-referral {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 50;
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="app" class="p-2 sm:p-4 md:p-8 max-w-7xl mx-auto">
        
        <header class="flex flex-col md:flex-row justify-between items-center py-4 border-b border-gray-700 mb-6">
            <h1 class="text-3xl font-extrabold text-purple-400 mb-4 md:mb-0">StreamFixer</h1>
            
            <div class="flex flex-wrap justify-center md:justify-end items-center space-x-2 sm:space-x-4">
                
                <button id="save-playlist-btn" class="bg-indigo-600 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg hover:bg-indigo-700 transition-colors text-sm font-medium shadow-lg hidden">
                    Save Playlist
                </button>
                <button id="view-saved-btn" class="p-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors shadow-lg">
                    <svg class="w-6 h-6 text-gray-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path></svg>
                </button>

                <div class="flex space-x-2">
                    <label for="file-upload" class="cursor-pointer bg-purple-600 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg hover:bg-purple-700 transition-colors text-sm font-medium shadow-lg">
                        Upload
                    </label>
                    <input type="file" id="file-upload" accept=".m3u" class="hidden">

                    <button id="import-url-btn" class="bg-gray-700 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg hover:bg-gray-600 transition-colors text-sm font-medium shadow-lg">
                        URL
                    </button>
                </div>
                
            </div>
        </header>

        <main id="editor-container" class="hidden">
            <p id="error-message" class="text-center text-lg text-red-500 my-4 hidden"></p>

            <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-between items-center mb-6 p-4 rounded-xl bg-gray-700/50 shadow-lg sticky top-0 z-20">
                
                <input type="text" id="search-input" placeholder="Filter by channel or URL..." class="p-2 border border-gray-600 rounded-lg w-full sm:max-w-xs focus:ring-purple-500 focus:border-purple-500 bg-gray-800 text-white">
                
                <div class="flex flex-wrap justify-center space-x-3 w-full sm:w-auto">
                    <button id="add-channel-btn" class="bg-green-600 text-white px-3 py-1.5 rounded-lg hover:bg-green-700 transition-colors text-sm font-medium shadow-md">
                        + Add
                    </button>
                    <button id="add-logos-btn" class="bg-blue-600 text-white px-3 py-1.5 rounded-lg hover:bg-blue-700 transition-colors text-sm font-medium shadow-md">
                        Auto Logos
                    </button>
                    <button id="bulk-name-btn" class="bg-yellow-600 text-white px-3 py-1.5 rounded-lg hover:bg-yellow-700 transition-colors text-sm font-medium shadow-md">
                        Bulk Rename
                    </button>
                </div>

                <button id="export-share-btn" class="bg-purple-600 text-white px-6 py-2 rounded-lg hover:bg-purple-700 transition-colors text-lg font-bold shadow-xl w-full sm:w-auto">
                    Export / Share
                </button>
            </div>

            <div id="loading-skeleton" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pb-8 hidden">
                ${Array(12).fill().map((_, i) => `
                    <div class="skeleton bg-gray-700/70 rounded-xl p-4 h-32">
                        <div class="h-6 w-3/4 bg-gray-600 rounded mb-3"></div>
                        <div class="h-4 w-1/2 bg-gray-600 rounded mb-6"></div>
                        <div class="flex space-x-3">
                            <div class="h-8 w-1/4 bg-purple-600 rounded-lg"></div>
                            <div class="h-8 w-1/4 bg-purple-600 rounded-lg"></div>
                        </div>
                    </div>
                `).join('')}
            </div>
            
            <div id="channel-list-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pb-8">
                </div>
            <p id="no-channels-msg" class="text-center text-gray-400 mt-8 hidden">No channels loaded yet.</p>

        </main>
        
        <div id="welcome-screen" class="text-center p-20">
            <h2 class="text-2xl font-semibold mb-4 text-gray-300">Welcome to the M3U Editor.</h2>
            <p class="text-gray-400">Import your playlist via **Upload** or **URL** to begin editing.</p>
        </div>

        <div id="telegram-referral" class="p-2 bg-gray-800/80 rounded-full shadow-2xl">
            <a href="https://t.me/MR_X_069" target="_blank" title="Join Telegram Channel">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-7 h-7 text-blue-400 hover:text-blue-300 transition-colors" fill="currentColor" viewBox="0 0 24 24"><path d="M11.944 0a12 12 0 1 0 12 12 12 12 0 0 0-12-12zm4.314 8.785a.722.722 0 0 1 .455.906l-2.028 9.53a.754.754 0 0 1-1.077.535l-3.213-2.454c-.21-.161-.5-.078-.718.146l-1.3 1.258a.723.723 0 0 1-1.229-.496l1.246-4.667c.18-.58.423-1.096.535-1.229.078-.078 0-.156 0-.234s0-.156-.156-.234L8.3 10.597a.755.755 0 0 1 .64-.476l5.7-.359a.722.722 0 0 1 .455.02z"/></svg>
            </a>
        </div>


        <div id="generic-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 modal-backdrop">
            <div class="bg-card-bg rounded-xl shadow-2xl w-full max-w-lg transition-all transform scale-100 p-6 max-h-[90vh] overflow-y-auto">
                
                <div class="flex justify-between items-start border-b pb-3 mb-4 border-gray-700 sticky top-0 bg-card-bg z-10">
                    <h3 id="modal-title" class="text-xl font-semibold">Modal Title</h3>
                    <button class="modal-close-btn text-gray-400 hover:text-gray-200">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>

                <div id="modal-content-area">
                    </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let channels = [];
        let currentlyEditingIndex = null;
        let currentPlaylistName = 'Current Working List'; 
        
        const LOCAL_STORAGE_KEY = 'm3ueditor_saved_playlists';
        const LAST_LOADED_KEY = 'm3ueditor_last_loaded';
        const LOGO_BASE_URL = 'https://raw.githubusercontent.com/iptv-org/tv-logos/master/logos/'; 

        // Uneditable default channel
        const TELEGRAM_CHANNEL = {
            name: 't.me/MR_X_069',
            logo: 'https://pixeldrain.com/api/file/zxiQyX1c/thumbnail',
            group: 't.me/MR_X_069',
            url: 'https://pixeldrain.com/api/file/zxiQyX1c'
        };

        // --- UI Utility Functions ---

        const showModal = (title, contentHTML) => {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-content-area').innerHTML = contentHTML;
            document.getElementById('generic-modal').classList.remove('hidden');
        };

        const hideModal = () => {
            document.getElementById('generic-modal').classList.add('hidden');
        };

        document.querySelector('.modal-close-btn').addEventListener('click', hideModal);

        const toggleEditorView = (show) => {
             const welcome = document.getElementById('welcome-screen');
             const editor = document.getElementById('editor-container');
             const saveBtn = document.getElementById('save-playlist-btn');

             if (show) {
                 welcome.classList.add('hidden');
                 editor.classList.remove('hidden');
                 saveBtn.classList.remove('hidden');
             } else {
                 welcome.classList.remove('hidden');
                 editor.classList.add('hidden');
                 saveBtn.classList.add('hidden');
             }
        }
        
        // --- Persistence (Save/Load/AutoSave) ---

        /** Loads all saved playlists from storage */
        const getSavedPlaylists = () => {
             const data = localStorage.getItem(LOCAL_STORAGE_KEY);
             return data ? JSON.parse(data) : {};
        };
        
        /** Saves the current channels list under the current playlist name, or 'Current Working List' */
        const savePlaylistToStorage = (name = currentPlaylistName, manual = false) => {
            if (channels.length === 0) return;

            const playlists = getSavedPlaylists();
            playlists[name] = {
                channels: channels,
                timestamp: Date.now(),
                name: name
            };

            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(playlists));
                currentPlaylistName = name; // Update current name
                localStorage.setItem(LAST_LOADED_KEY, name); // Remember last loaded name
                
                if (!manual) {
                    const saveBtn = document.getElementById('save-playlist-btn');
                    // Briefly change the button text to show auto-save is working
                    saveBtn.textContent = 'Auto-Saved!';
                    setTimeout(() => saveBtn.textContent = 'Save Playlist', 1500);
                }
            } catch (e) {
                console.error("Failed to save to local storage:", e);
                // alert("Warning: Could not save playlist to local storage. Storage full?");
            }
        };

        /** Loads a specific named playlist from storage */
        const loadNamedPlaylist = (name) => {
            const playlists = getSavedPlaylists();
            const playlist = playlists[name];

            if (playlist && playlist.channels.length > 0) {
                channels = playlist.channels;
                currentPlaylistName = name;
                localStorage.setItem(LAST_LOADED_KEY, name);
                renderChannels();
                toggleEditorView(true);
                return true;
            }
            return false;
        };

        // Manual Save Handler
        document.getElementById('save-playlist-btn').addEventListener('click', () => {
            const content = `
                <p class="mb-4 text-gray-300">Name this playlist for future editing. It currently has **${channels.length} channels**.</p>
                <input type="text" id="save-name-input" value="${currentPlaylistName}" class="w-full p-3 border border-gray-700 rounded-lg bg-gray-800 text-white" placeholder="Enter Playlist Name" />
                <button id="submit-save-btn" class="mt-4 bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 w-full font-semibold">Confirm Save</button>
            `;
            showModal('Save Playlist', content);

            document.getElementById('submit-save-btn').addEventListener('click', () => {
                const newName = document.getElementById('save-name-input').value.trim() || `Playlist ${new Date().toLocaleTimeString()}`;
                savePlaylistToStorage(newName, true);
                alert(`Playlist saved as "${newName}".`);
                hideModal();
            });
        });


        // --- View Saved Modal (Updated to list multiple named playlists) ---

        document.getElementById('view-saved-btn').addEventListener('click', () => {
            const playlists = getSavedPlaylists();
            const playlistKeys = Object.keys(playlists).sort((a, b) => playlists[b].timestamp - playlists[a].timestamp);

            if (playlistKeys.length === 0) {
                showModal('Saved Playlists', '<p class="text-center text-gray-400">No playlists found in local storage. Use the "Save Playlist" button to create one.</p>');
                return;
            }

            let content = `<p class="mb-4 text-gray-300">Select a playlist to load or delete:</p><div class="space-y-3">`;

            playlistKeys.forEach(key => {
                const p = playlists[key];
                const date = new Date(p.timestamp).toLocaleString();
                content += `
                    <div class="p-3 bg-gray-700 rounded-lg flex justify-between items-center">
                        <div>
                            <p class="font-semibold text-white">${p.name}</p>
                            <p class="text-xs text-gray-400">${p.channels.length} channels | Saved: ${date}</p>
                        </div>
                        <div class="flex space-x-2">
                            <button data-name="${p.name}" class="load-saved-item-btn bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1 rounded-md font-medium">Load</button>
                            <button data-name="${p.name}" class="delete-saved-item-btn bg-red-600 hover:bg-red-700 text-white text-xs px-3 py-1 rounded-md font-medium">Delete</button>
                        </div>
                    </div>
                `;
            });
            content += '</div>';

            showModal('View Saved Playlists', content);

            // Attach listeners to dynamically created buttons
            document.querySelectorAll('.load-saved-item-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const name = e.currentTarget.dataset.name;
                    if (loadNamedPlaylist(name)) {
                        hideModal();
                    } else {
                        alert('Failed to load playlist.');
                    }
                });
            });

            document.querySelectorAll('.delete-saved-item-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const nameToDelete = e.currentTarget.dataset.name;
                    if(confirm(`Are you sure you want to delete the playlist "${nameToDelete}"?`)) {
                        const allPlaylists = getSavedPlaylists();
                        delete allPlaylists[nameToDelete];
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(allPlaylists));
                        alert(`Playlist "${nameToDelete}" deleted.`);
                        // If the deleted one was the current one, reset the current state
                        if (currentPlaylistName === nameToDelete) {
                             currentPlaylistName = 'Current Working List';
                             localStorage.removeItem(LAST_LOADED_KEY);
                        }
                        document.getElementById('view-saved-btn').click(); // Re-open the modal to refresh list
                    }
                });
            });
        });
        
        // --- M3U Parsing & Loading ---
        
        const parseM3U = (text) => {
            // ... (Parsing logic remains the same) ...
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines[0] !== '#EXTM3U') {
                throw new Error("Invalid M3U file format. Must start with #EXTM3U.");
            }

            const parsedChannels = [];
            let currentChannel = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];

                if (line.startsWith('#EXTINF')) {
                    currentChannel = {};
                    const attributesString = line.substring(line.indexOf(' ')).split(',')[0].trim();
                    const attributes = attributesString.match(/([^=]+)="([^"]*)"/g) || [];
                    
                    attributes.forEach(attr => {
                        const [key, value] = attr.split('=').map(s => s.replace(/"/g, ''));
                        if (key.toLowerCase() === 'tvg-name' || key.toLowerCase() === 'channel-name') currentChannel.name = value;
                        if (key.toLowerCase() === 'tvg-logo' || key.toLowerCase() === 'logo') currentChannel.logo = value;
                        if (key.toLowerCase() === 'group-title') currentChannel.group = value;
                    });

                    const channelTitle = line.substring(line.lastIndexOf(',') + 1).trim();
                    currentChannel.name = (currentChannel.name && currentChannel.name !== '') ? currentChannel.name : channelTitle;
                    currentChannel.logo = currentChannel.logo || '';
                    currentChannel.group = currentChannel.group || 'General';

                } else if (line.startsWith('http')) {
                    currentChannel.url = line;
                    parsedChannels.push(currentChannel);
                    currentChannel = {};
                }
            }
            return parsedChannels;
        };

        const loadM3UContent = (content, loadedChannels = null) => {
            const skeleton = document.getElementById('loading-skeleton');
            const errorMessage = document.getElementById('error-message');
            
            toggleEditorView(true); // Show editor and hide welcome
            
            skeleton.classList.remove('hidden');
            errorMessage.classList.add('hidden');

            // Reset current name for new imports
            if (!loadedChannels) {
                 currentPlaylistName = 'Current Working List';
            }

            setTimeout(() => { // Simulate network/parsing delay for the animation
                try {
                    let newChannels;
                    if (loadedChannels) {
                        newChannels = loadedChannels; // Loaded from local storage
                    } else {
                        newChannels = parseM3U(content); // Loaded from file/url
                    }
                    
                    channels = newChannels.filter(c => c.url);
                    skeleton.classList.add('hidden');
                    renderChannels();
                    savePlaylistToStorage(currentPlaylistName, false); // Auto-save on successful load
                } catch (error) {
                    skeleton.classList.add('hidden');
                    errorMessage.textContent = `Error loading M3U: ${error.message}`;
                    errorMessage.classList.remove('hidden');
                    channels = [];
                    renderChannels();
                    toggleEditorView(false); // Go back if error is fatal
                }
            }, 500);
        };

        // --- Import Handlers (Same as previous version, calling loadM3UContent) ---
        
        document.getElementById('file-upload').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => loadM3UContent(e.target.result);
            reader.readAsText(file);
        });

        document.getElementById('import-url-btn').addEventListener('click', () => {
            const content = `
                <input type="url" id="url-input" class="w-full p-3 border border-gray-700 rounded-lg bg-gray-800 text-white" placeholder="Enter full M3U URL" />
                <button id="submit-url-btn" class="mt-4 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 w-full">Fetch Playlist</button>
                <p id="url-status-message" class="mt-2 text-sm text-center text-gray-400"></p>
            `;
            showModal('Import Playlist via URL', content);

            document.getElementById('submit-url-btn').addEventListener('click', async () => {
                const url = document.getElementById('url-input').value;
                const statusMessage = document.getElementById('url-status-message');
                if (!url) return;
                
                statusMessage.textContent = 'Fetching... This may take a moment.';
                
                try {
                    const response = await fetch(url); 
                    if (!response.ok) throw new Error(`HTTP error ${response.status}. Check URL and CORS policy.`);
                    
                    const text = await response.text();
                    loadM3UContent(text);
                    hideModal();
                } catch (error) {
                    statusMessage.textContent = `Failed: ${error.message}`;
                    statusMessage.classList.add('text-red-500');
                    console.error('URL Fetch Error:', error);
                }
            });
        });

        // --- Data Editing and Rendering (Updated to call save on edit) ---

        const handleInlineEdit = (e) => {
            const input = e.target;
            const index = parseInt(input.dataset.index);
            const field = input.dataset.field;
            const newValue = input.value.trim();

            if (index >= 0 && index < channels.length) {
                channels[index][field] = newValue;
                renderChannels();
                savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
            }
        };
        
        const renderChannels = () => {
             // ... (Rendering logic remains the same) ...
             const container = document.getElementById('channel-list-container');
            const searchText = document.getElementById('search-input').value.toLowerCase();
            const filteredChannels = channels.filter(c => 
                c.name.toLowerCase().includes(searchText) || 
                c.group.toLowerCase().includes(searchText) ||
                c.url.toLowerCase().includes(searchText)
            );

            container.innerHTML = ''; 

            if (filteredChannels.length === 0 && channels.length > 0) {
                document.getElementById('no-channels-msg').textContent = "No channels match your current filter.";
                document.getElementById('no-channels-msg').classList.remove('hidden');
                return;
            } else if (channels.length === 0) {
                document.getElementById('no-channels-msg').textContent = "No channels loaded yet.";
                document.getElementById('no-channels-msg').classList.remove('hidden');
                return;
            }
            document.getElementById('no-channels-msg').classList.add('hidden');
            
            filteredChannels.forEach((channel, index) => {
                const originalIndex = channels.findIndex(c => c === channel); 

                const card = document.createElement('div');
                card.className = 'bg-card-bg rounded-xl p-4 shadow-xl border border-gray-700/50 flex flex-col space-y-3';
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <div class="flex-shrink-0 w-12 h-12 bg-gray-700 rounded-md overflow-hidden flex items-center justify-center mr-3">
                            ${channel.logo 
                                ? `<img src="${channel.logo}" alt="${channel.name} logo" class="w-full h-full object-contain p-1" onerror="this.onerror=null;this.src='https://via.placeholder.com/48?text=?'">`
                                : '<span class="text-xs text-gray-400">N/A</span>'}
                        </div>
                        <div class="flex-grow min-w-0">
                            <input type="text" value="${channel.name}" data-index="${originalIndex}" data-field="name" 
                                   class="editable-name font-bold text-lg w-full p-0.5 rounded-md truncate focus:shadow-none" 
                                   title="Click to edit Name" />
                            
                            <div class="text-xs text-purple-400 mt-1">
                                <input type="text" value="${channel.group}" data-index="${originalIndex}" data-field="group" 
                                       class="editable-group font-medium w-full p-0.5 rounded-md focus:shadow-none" 
                                       title="Click to edit Group" />
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-start space-x-3 pt-3 border-t border-gray-700">
                        <button class="play-btn bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded-lg text-sm font-medium flex items-center space-x-1 transition-colors" data-index="${originalIndex}">
                             <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                             <span>Play</span>
                        </button>
                        <button class="edit-btn bg-gray-700 hover:bg-gray-600 text-white px-3 py-1.5 rounded-lg text-sm font-medium flex items-center space-x-1 transition-colors" data-index="${originalIndex}">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                            <span>Edit</span>
                        </button>
                    </div>
                `;
                container.appendChild(card);
            });

            attachActionListeners();
        };

        const attachActionListeners = () => {
            // Remove existing listeners to prevent duplicates
            document.getElementById('search-input').oninput = renderChannels;
            document.querySelectorAll('.editable-name, .editable-group').forEach(input => {
                input.onchange = handleInlineEdit;
            });
            // Re-attach play/edit listeners
            document.querySelectorAll('.edit-btn').forEach(button => {
                button.onclick = (e) => showFullEditModal(e.currentTarget.dataset.index);
            });
            document.querySelectorAll('.play-btn').forEach(button => {
                button.onclick = (e) => showPlaybackModal(e.currentTarget.dataset.index);
            });
        };


        const showFullEditModal = (index, isNew = false) => {
            currentlyEditingIndex = parseInt(index);
            const channel = channels[currentlyEditingIndex] || { name: '', logo: '', group: '', url: '' };
            
            const content = `
                <div class="space-y-4">
                    <label class="block text-gray-300">Channel Name:
                        <input type="text" id="edit-name" value="${channel.name}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">Logo URL:
                        <input type="url" id="edit-logo" value="${channel.logo}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">Group Title:
                        <input type="text" id="edit-group" value="${channel.group}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">Stream URL (Full M3U8/HTTP link):
                        <textarea id="edit-url" rows="3" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">${channel.url}</textarea>
                    </label>
                </div>
                <div class="flex justify-between mt-6 space-x-3">
                    <button id="delete-channel-btn" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 font-semibold flex-1 ${isNew ? 'hidden' : ''}">Delete</button>
                    <button id="save-channel-btn" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 font-semibold flex-1">Save & Close</button>
                </div>
            `;
            showModal(isNew ? 'Add New Channel' : 'Edit Full Details', content);

            document.getElementById('save-channel-btn').addEventListener('click', () => {
                channels[currentlyEditingIndex] = {
                    name: document.getElementById('edit-name').value.trim(),
                    logo: document.getElementById('edit-logo').value.trim(),
                    group: document.getElementById('edit-group').value.trim(),
                    url: document.getElementById('edit-url').value.trim(),
                };
                renderChannels();
                savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                hideModal();
            });

            if (!isNew) {
                 document.getElementById('delete-channel-btn').addEventListener('click', () => {
                    if (confirm("Are you sure you want to delete this channel?")) {
                        channels.splice(currentlyEditingIndex, 1);
                        renderChannels();
                        savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                        hideModal();
                    }
                 });
            }
        };

        document.getElementById('add-channel-btn').addEventListener('click', () => {
            const newChannelTemplate = { name: 'New Channel', logo: '', group: 'Custom', url: '' };
            channels.push(newChannelTemplate);
            showFullEditModal(channels.length - 1, true); 
        });


        // --- ADVANCED Bulk Editor (Fixed scroll issue) ---
        
        document.getElementById('bulk-name-btn').addEventListener('click', () => {
            if (channels.length === 0) {
                 alert("Please load a playlist first.");
                 return;
             }
             
            // The modal itself is scrollable via the added style: max-h-[90vh] overflow-y-auto
            const content = `
                <div class="space-y-4">
                    <p class="mb-4 text-sm text-gray-400">Apply a change to a continuous range of channels.</p>
                    
                    <h4 class="text-md font-semibold text-purple-400">1. Channel Range</h4>
                    <label class="block text-gray-300">Start Row # (1 for first channel):
                        <input type="number" id="start-index" value="1" min="1" max="${channels.length}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>
                    <label class="block text-gray-300">End Row # (Optional, leave blank for all remaining):
                        <input type="number" id="end-index" value="${channels.length}" min="1" max="${channels.length}" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                    </label>

                    <h4 class="text-md font-semibold text-purple-400 pt-4 border-t border-gray-700">2. Renaming (Optional)</h4>
                    <label class="block text-gray-300">Base Name (Optional, for S/E numbering):
                        <input type="text" id="bulk-base-name" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1" placeholder="e.g., The Series Title">
                    </label>
                    <div class="flex space-x-4">
                        <label class="block w-1/2 text-gray-300">Start Season (e.g., 1):
                            <input type="number" id="start-season" value="1" min="1" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                        </label>
                        <label class="block w-1/2 text-gray-300">Start Episode (e.g., 1):
                            <input type="number" id="start-episode" value="1" min="1" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1">
                        </label>
                    </div>

                    <h4 class="text-md font-semibold text-purple-400 pt-4 border-t border-gray-700">3. Other Bulk Edits (Optional)</h4>
                    <label class="block text-gray-300">New Group Title (Optional, leave blank to skip):
                        <input type="text" id="new-group-title" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1" placeholder="e.g., Movies HD">
                    </label>
                    <label class="block text-gray-300">New Logo URL (Optional, leave blank to skip):
                        <input type="url" id="new-logo-url" class="w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white mt-1" placeholder="e.g., http://mylogos.com/default.png">
                    </label>
                </div>
                <button id="submit-bulk-name-btn" class="mt-6 bg-yellow-600 text-white px-4 py-2 rounded-lg hover:bg-yellow-700 w-full font-semibold">Apply Bulk Edits</button>
                <p id="bulk-status-message" class="mt-3 text-center text-sm text-gray-400"></p>
            `;
            showModal('Advanced Bulk Editor', content);

            document.getElementById('submit-bulk-name-btn').addEventListener('click', () => {
                const baseName = document.getElementById('bulk-base-name').value.trim();
                let currentSeason = parseInt(document.getElementById('start-season').value);
                let currentEpisode = parseInt(document.getElementById('start-episode').value);
                const startIndex = parseInt(document.getElementById('start-index').value) - 1; // 0-based
                const endIndex = parseInt(document.getElementById('end-index').value); // Exclusive/end index is usually the number itself
                const newGroupTitle = document.getElementById('new-group-title').value.trim();
                const newLogoUrl = document.getElementById('new-logo-url').value.trim();

                const statusMessage = document.getElementById('bulk-status-message');
                let count = 0;

                if (startIndex < 0 || startIndex >= channels.length) {
                    statusMessage.textContent = 'Start Row number is invalid.';
                    statusMessage.classList.add('text-red-500');
                    return;
                }

                const actualEndIndex = Math.min(endIndex, channels.length);

                for (let i = startIndex; i < actualEndIndex; i++) {
                    // 1. Rename logic (S/E sequencing)
                    if (baseName || !isNaN(currentSeason) || !isNaN(currentEpisode)) {
                        const s = String(currentSeason).padStart(2, '0');
                        const e = String(currentEpisode).padStart(2, '0');
                        const prefix = `S${s}E${e}`;
                        
                        channels[i].name = baseName ? `${baseName} - ${prefix}` : `${prefix} ${channels[i].name}`;
                        currentEpisode++;
                    }

                    // 2. Group Title change
                    if (newGroupTitle) {
                        channels[i].group = newGroupTitle;
                    }

                    // 3. Logo URL change
                    if (newLogoUrl) {
                        channels[i].logo = newLogoUrl;
                    }

                    count++;
                }
                
                renderChannels();
                savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                statusMessage.textContent = `Successfully updated ${count} channels.`;
                statusMessage.classList.remove('text-red-500');
                statusMessage.classList.add('text-green-500');
                setTimeout(hideModal, 2000);
            });
        });

        // --- Logo Matching Logic (Same as previous version, updated to call save) ---
        
        const slugifyChannelName = (name) => {
             return name
                .toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^\w\-]+/g, '')
                .replace(/\-\-+/g, '-')
                .replace(/^-+/, '')
                .replace(/-+$/, '');
        };

        document.getElementById('add-logos-btn').addEventListener('click', () => {
             if (channels.length === 0) {
                 alert("Please load a playlist first.");
                 return;
             }

             const channelGroups = [...new Set(channels.map(c => c.group))];
             const groupOptions = channelGroups.map(g => `<option value="${g}">${g}</option>`).join('');

             const content = `
                <div class="space-y-4">
                    <p class="mb-4 text-sm text-gray-400">Match channel names to logos using a database structure. Use 'Specific Group' for **multiple logo ranges**.</p>
                    <label class="block text-gray-300">Target Channels:
                        <select id="logo-target" class="mt-1 block w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white">
                            <option value="all">All Channels</option>
                            <option value="missing">Only Channels with Missing Logos</option>
                            <option value="group">Specific Group...</option>
                        </select>
                    </label>

                    <label id="group-select-container" class="block hidden text-gray-300">Select Group:
                        <select id="logo-group-target" class="mt-1 block w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white">
                            ${groupOptions}
                        </select>
                    </label>

                    <label class="block text-gray-300">Base Logo URL:
                        <input type="text" id="logo-base-input" value="${LOGO_BASE_URL}" class="mt-1 block w-full p-2 border border-gray-700 rounded-md bg-gray-700 text-white">
                        <p class="text-xs text-gray-500 mt-1">URL format: BASE_URL/[channel-name-slugified].png</p>
                    </label>
                </div>
                
                <button id="submit-logo-btn" class="mt-6 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 w-full font-semibold">Apply Logos</button>
                <p id="logo-status-message" class="mt-3 text-center text-sm text-gray-400"></p>
             `;
             showModal('Auto Add Logos', content);

             document.getElementById('logo-target').addEventListener('change', (e) => {
                 document.getElementById('group-select-container').classList.toggle('hidden', e.target.value !== 'group');
             });

             document.getElementById('submit-logo-btn').addEventListener('click', () => {
                 const target = document.getElementById('logo-target').value;
                 const baseLogoUrl = document.getElementById('logo-base-input').value.trim().replace(/\/+$/, '');
                 const groupTarget = document.getElementById('logo-group-target')?.value;
                 const statusMessage = document.getElementById('logo-status-message');
                 let logosAppliedCount = 0;
                 
                 channels = channels.map(channel => {
                     let shouldApply = false;
                     if (target === 'all') shouldApply = true;
                     else if (target === 'missing' && channel.logo === '') shouldApply = true;
                     else if (target === 'group' && channel.group === groupTarget) shouldApply = true;

                     if (shouldApply) {
                         const slug = slugifyChannelName(channel.name);
                         const newLogoUrl = baseLogoUrl + '/' + slug + '.png';
                         
                         if (channel.logo !== newLogoUrl) {
                             channel.logo = newLogoUrl;
                             logosAppliedCount++;
                         }
                     }
                     return channel;
                 });

                 renderChannels();
                 savePlaylistToStorage(currentPlaylistName, false); // AUTO-SAVE
                 statusMessage.textContent = `Success! Updated logos for ${logosAppliedCount} channels.`;
                 statusMessage.classList.remove('text-red-500');
                 statusMessage.classList.add('text-green-500');
                 setTimeout(hideModal, 2000);
             });
        });

        // --- Export and Share Logic (Modified to include Telegram channel) ---

        const generateM3UPlaylist = (channelList) => {
            let m3uContent = '#EXTM3U\n';
            
            // 1. Add mandatory Telegram channel first
            m3uContent += '#EXTINF:-1';
            m3uContent += ` tvg-logo="${TELEGRAM_CHANNEL.logo}"`;
            m3uContent += ` group-title="${TELEGRAM_CHANNEL.group}"`;
            m3uContent += `,${TELEGRAM_CHANNEL.name}\n`;
            m3uContent += `${TELEGRAM_CHANNEL.url}\n`;

            // 2. Add user's channels
            channelList.forEach(channel => {
                if (!channel.name || !channel.url) return; 
                m3uContent += '#EXTINF:-1';
                if (channel.logo && channel.logo.length > 0) m3uContent += ` tvg-logo="${channel.logo}"`;
                if (channel.group && channel.group.length > 0) m3uContent += ` group-title="${channel.group}"`;
                m3uContent += `,${channel.name}\n`;
                m3uContent += `${channel.url}\n`;
            });
            return m3uContent;
        };

        document.getElementById('export-share-btn').addEventListener('click', () => {
            const m3uCode = generateM3UPlaylist(channels);
            
            const content = `
                <div class="space-y-4">
                    <p class="text-gray-300">Select an option to save or share your updated playlist. The **t.me/MR_X_069** channel is automatically included.</p>
                    <textarea id="playlist-code-display" rows="8" readonly class="w-full p-3 border border-gray-700 rounded-lg bg-gray-900 text-green-400 text-sm font-mono">${m3uCode}</textarea>

                    <div class="flex flex-col space-y-3">
                        <button id="copy-code-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 font-semibold transition-colors">Copy Full M3U Playlist Code</button>
                        <button id="download-m3u-btn" data-format="m3u" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 font-semibold transition-colors">Download as .m3u File</button>
                        <button id="download-txt-btn" data-format="txt" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 font-semibold transition-colors">Download as .txt File (Plain Text)</button>
                    </div>
                    <p id="export-status" class="mt-3 text-center text-sm text-gray-400"></p>
                </div>
            `;
            showModal('Export & Share Playlist', content);

            // Copy to Clipboard Logic
            document.getElementById('copy-code-btn').addEventListener('click', () => {
                navigator.clipboard.writeText(m3uCode).then(() => {
                    const status = document.getElementById('export-status');
                    status.textContent = 'Playlist code copied to clipboard!';
                    status.classList.add('text-green-400');
                    setTimeout(() => status.textContent = '', 1500);
                }).catch(err => {
                    document.getElementById('export-status').textContent = 'Failed to copy.';
                    console.error('Copy failed: ', err);
                });
            });

            // Download Logic
            document.getElementById('download-m3u-btn').addEventListener('click', (e) => downloadFile(m3uCode, `M3U_Editor_Pro_${currentPlaylistName.replace(/[^a-zA-Z0-9]/g, '_')}.m3u`, 'audio/x-mpegurl'));
            document.getElementById('download-txt-btn').addEventListener('click', (e) => downloadFile(m3uCode, `M3U_Editor_Pro_${currentPlaylistName.replace(/[^a-zA-Z0-9]/g, '_')}.txt`, 'text/plain'));
        });
        
        const downloadFile = (content, fileName, mimeType) => {
            const blob = new Blob([content], { type: mimeType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            const status = document.getElementById('export-status');
            status.textContent = `Downloading ${fileName}...`;
            status.classList.add('text-green-400');
            setTimeout(() => status.textContent = '', 1500);
        };
        
        // --- Playback Modal Logic (Modified to show Name and Logo) ---

        const showPlaybackModal = (index) => {
            const channel = channels[parseInt(index)];
            const url = channel.url;
            const isHLS = url.toLowerCase().includes('.m3u8');
            
            const playerHTML = `
                <div class="flex items-center space-x-3 mb-4">
                    <img src="${channel.logo}" alt="Logo" class="w-10 h-10 object-contain bg-gray-700 rounded-md p-0.5" onerror="this.onerror=null;this.src='https://via.placeholder.com/40?text=?'">
                    <h4 class="text-xl font-bold">${channel.name}</h4>
                </div>
                <video id="video-player" controls autoplay class="w-full bg-black rounded-lg shadow-xl" poster="https://via.placeholder.com/600x300?text=Loading+Stream"></video>
                <p id="player-status" class="mt-4 text-center text-sm text-yellow-400"></p>
                <p class="mt-2 text-xs break-all text-gray-500">Source: ${url.substring(0, 50)}...</p>
            `;
            showModal('Test Playback', playerHTML);
            document.getElementById('player-status').textContent = 'Initializing player...';

            const video = document.getElementById('video-player');
            
            if (isHLS && Hls.isSupported()) {
                const hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(video);
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    video.play().catch(() => {});
                    document.getElementById('player-status').textContent = 'Playback successful (HLS.js)';
                });
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        document.getElementById('player-status').textContent = `HLS Error: ${data.details}. Trying native fallback.`;
                        video.src = url;
                        video.play().catch(() => {
                            document.getElementById('player-status').textContent = `Playback Failed: Stream invalid or CORS blocked.`;
                        });
                    }
                });
            } else {
                video.src = url;
                video.play().catch(e => {
                    document.getElementById('player-status').textContent = `Playback Failed. Stream invalid, format unsupported, or CORS blocked.`;
                });
            }
        };


        // --- Initialization ---

        const checkInitialState = () => {
            const lastLoadedName = localStorage.getItem(LAST_LOADED_KEY);
            
            if (lastLoadedName) {
                // Attempt to auto-load the last working playlist
                const playlists = getSavedPlaylists();
                if (playlists[lastLoadedName]) {
                    loadNamedPlaylist(lastLoadedName);
                    return;
                }
            }
            // If no last loaded name or list is gone, show welcome screen
            toggleEditorView(false);
        }
        
        checkInitialState();
    </script>
</body>
</html>
